<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>群青症候群｜Official Site</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="startModal" class="modal-overlay">
        <div class="modal-content">
            <p>このサイトはBGMが流れます。<br>再生しますか？</p>
            <div class="modal-buttons">
                <button onclick="startSite(true)">はい</button>
                <button onclick="startSite(false)">いいえ</button>
            </div>
        </div>
    </div>
    
    <button id="bgmToggleBtn" class="bgm-float-btn" onclick="toggleBgm()">
        <span id="bgmIcon">🔇</span> OFF
    </button>
    <header class="site-header">
        <h1>群青症候群</h1>
        <nav>
            <ul>
                <li><a href="#prologue">Prologue</a></li>
                <li><a href="#world">World</a></li>
                <li><a href="#character">Character</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section id="prologue" class="novel-text">
            <h2>Prologue</h2>
            <p>死期が見えるようになった。<br>
            西暦何年何月何日。<br>
            時間までは書いていない。<br>
            でもその日に必ず死は訪れる。</p>

            <p>いつから見えるようになったかは覚えていない。<br>
            最初はただ数字が頭上に浮かんでいるだけだと思っていた。<br>
            俺は不謹慎にもその数字が当日と一致する日を待ちわびてしまった。というのも、毎朝元気な挨拶をしてくれる近所のおじいさんがもうすぐでその数字が近づいていたのだ。</p>

            <p>当日の朝、おじいさんの挨拶はなかった。<br>
            その日の夕方、パトカーが物々しく赤いランプを音を立てずに回っていたのが脳裏にこびりついている。<br>
            原因は夜中の心筋梗塞。</p>

            <p>発見に至ったのはおじいさんと面識のある町内会のおばさん達。<br>
            毎朝のご近所づきあいに決められた時間に世間話しに来なかったため確認しに行ったところ、違和感を覚え警察を呼びそのまま確認に至る。</p>

            <p>そんな詳しい話を晩ご飯の最中に聞かされ、食べ物が喉を通りにくかったことを覚えている。だが、もっと喉を通らなくなったことがある。</p>

            <p>近所の野良猫だ。</p>

            <p>この猫も同じく頭上の数字が近づいていた。まるで自分の死期を眺めるように中空をじっと眺めていた猫はとても年老いていた。</p>

            <p>俺はその後ろを一日中追いかけ、落ちてくる花瓶、急発進する車、真っ黒な服に身を包み時折光り物をちらつかせる怪しい男など、その日は不幸が凝縮されたような厄日から猫を守ろうとした。</p>

            <p>真夜中、静まった裏路地、くぼみの隙間で丸くなり、それから重い瞼が開くことも、一声鳴くこともなく、猫の頭上から数字が消えた。</p>

            <p>その場を藍色の闇が静寂を支配し、藍色の月がにやにやと笑うように淡く光っていた。</p>

            <p>死からは逃げられない。<br>
            どんな過程をたどろうとも夜は等しく降りてくるのだと。<br>
            そのときから自分にとって死の数字は隣人になった。</p>
            
            <hr class="fade-line">

            <p>夜遅く帰宅して親にこっぴどく叱られた。泣かれて怒られて抱きしめられ、そんな親の姿は初めてで、自分の身体が軋みに耐えかね悲鳴をあげる中、親の頭上には長生きの数字が記載されていた。ひどく安心してしまった。</p>

            <p>自分の頭の上を鏡で見て、親不孝者にはならないことを何度も確認したのは……ちょっと今のは恥ずかしいから聞かないで。</p>

            <p>今までの話は俺が中学生までの過去話だ。何者も恐れない中二的思考回路、その自信はどこから来るのか自分でも問いただしたかったが、自分の能力をひけらかした過去は戻らない。未来を生きているはずの僕らは過去に縛られ、そしていつか時間も止まってしまう。</p>
        </section>

        <section id="world" class="world-section">
            <h2>World</h2>
            <div class="poetic-text">
                <p>哀で満ちた藍色の天蓋。<br>
                愛を祈る藍色の巨人。<br>
                瞳が映す世界はとても退屈なもので<br>
                誰もが特別でない特別な世界。</p>
                
                <p>そんな世界で主人公：シキは<br>
                死期が見えるようになる。</p>
            </div>
        </section>

        <section id="character">
            <h2>Character</h2>
            
            <div class="char-card">
                <div class="char-img">
                     <div id="deathTimer" class="death-timer-container"></div> <div class="slider-container">
                            <button class="nav-btn prev-btn" onclick="changeImage(-1)"></button>
                            <img id="charImage" src="images/kokorone1.png" alt="ココロネ">
        
                            <div id="deathTimer" class="death-timer-container"></div> 

                            <button class="nav-btn next-btn" onclick="changeImage(1)"></button>
                     </div>
                    </div>
                <div class="char-info">
                    <h3>ココロネ</h3>
                    <p class="char-role">心が読める少女</p>
                    <p>「1週間……1週間しかないんだね。」</p>
                    <p>
                        祈るように手を合わせている少女。<br>
                        主人公の心を読んで自分の死期を悟る。<br>
                        けれど慌てた様子はなく、むしろ穏やかな表情を浮かべ……？
                    </p>
                </div>
            </div>
            
        </section>

    </main>

    <footer>
        <p>&copy; 2024 YodomiADI / Studio YomiDomi</p>
    </footer>

    <script>
        // --- 共通変数 ---
    let totalSeconds = (6 * 24 * 60 * 60) + (3 * 60 * 60);
    const timerDisplay = document.getElementById("deathTimer");
    const imageContainer = document.querySelector(".slider-container");
    const bgmBtn = document.getElementById("bgmToggleBtn");
    const modal = document.getElementById("startModal");

    // --- 画像切り替え ---
    const images = ["images/kokorone1.png", "images/kokorone2.png"];
    let currentIndex = 0; 
    function changeImage(direction) {
        currentIndex = (currentIndex + direction + images.length) % images.length;
        document.getElementById("charImage").src = images[currentIndex];
    }

    // --- BGM制御 (Web Audio API: 隙間なしループ) ---
    let audioContext = null;
    let bgmSource = null;
    let bgmBuffer = null;
    let isPlaying = false;
    const bgmUrl = 'audio/bgm.m4a'; // パスが正しいか確認してください

    async function loadAudio() {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            const response = await fetch(bgmUrl);
            if (!response.ok) throw new Error("ファイルが見つかりません");
            const arrayBuffer = await response.arrayBuffer();
            bgmBuffer = await audioContext.decodeAudioData(arrayBuffer);
            console.log("BGM読み込み完了");
        } catch (e) {
            console.error("BGMエラー:", e);
            // 万が一Web Audioが失敗した時のための予備（通常再生）
        }
    }

    async function startSite(allowMusic) {
        modal.style.opacity = '0';
        setTimeout(() => {
            modal.style.display = 'none';
            bgmBtn.style.display = 'block';
        }, 500);

        if (allowMusic) {
            await loadAudio();
            playBgm();
        }
    }

    function toggleBgm() {
        if (isPlaying) stopBgm(); else playBgm();
    }

    function playBgm() {
        if (!bgmBuffer) return;
        if (audioContext.state === 'suspended') audioContext.resume();
        bgmSource = audioContext.createBufferSource();
        bgmSource.buffer = bgmBuffer;
        bgmSource.loop = true;
        const gainNode = audioContext.createGain();
        gainNode.gain.value = 1.0; 
        bgmSource.connect(gainNode);
        gainNode.connect(audioContext.destination);
        bgmSource.start(0);
        isPlaying = true;
        updateBtnView(true);
    }

    function stopBgm() {
        if (bgmSource) { bgmSource.stop(); bgmSource = null; }
        isPlaying = false;
        updateBtnView(false);
    }

    function updateBtnView(on) {
        bgmBtn.innerHTML = on ? '<span style="color:#93c5fd;">🔊</span> ON' : '<span style="color:#64748b;">🔇</span> OFF';
        bgmBtn.style.borderColor = on ? "#93c5fd" : "#64748b";
    }

    // --- 死期タイマー (常時カウント) ---
    setInterval(() => {
        if (totalSeconds > 0) totalSeconds--;
        if (timerDisplay.classList.contains("visible")) {
            timerDisplay.innerText = formatTime(totalSeconds);
        }
    }, 1000);

    function formatTime(seconds) {
        if (seconds < 0) seconds = 0;
        const m = Math.floor(seconds / (30 * 24 * 3600));
        let rem = seconds % (30 * 24 * 3600);
        const d = Math.floor(rem / (24 * 3600));
        rem %= (24 * 3600);
        const h = Math.floor(rem / 3600);
        rem %= 3600;
        const min = Math.floor(rem / 60);
        const s = rem % 60;
        return `${m}:${d}:${h}:${String(min).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    // --- 観測システム (マウス・タッチ) ---
    function startObserving(e) {
        // 【重要】e が定義されていないエラーを防ぐ
        if(e && e.type === 'touchstart') {
            // e.cancelable が true の時だけ preventDefault を呼ぶ（ブラウザエラー回避）
            if (e.cancelable) e.preventDefault();
        }
        timerDisplay.innerText = formatTime(totalSeconds);
        timerDisplay.classList.add("visible");
    }

    function stopObserving() {
        timerDisplay.classList.remove("visible");
    }

    imageContainer.addEventListener("mouseenter", startObserving);
    imageContainer.addEventListener("mouseleave", stopObserving);
    imageContainer.addEventListener("touchstart", startObserving, {passive: false});
    imageContainer.addEventListener("touchend", stopObserving);
    </script>
</body>
</html>